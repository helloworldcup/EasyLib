#include "packet.h"
#include "ldd/net/incoming_msg.h"
#include "ldd/net/outgoing_msg.h"

namespace ldd { namespace net {

Request::Request(OutgoingMsg *msg) 
        : msg_(msg), type_(Packet::kOutgoing)
{
}

Request::~Request()
{
    //由channel来删除
    //if (msg_ != NULL) {
    //    //delete msg_;
    //}
    //LOG(INFO) << "Request::~Request: destructor called";
}

void Request::AppendTo(std::vector<boost::asio::const_buffer>* buffers)
{
    CHECK_NOTNULL(buffers);

    Header::Builder hdr(header_);

    msg_->SerializeTo(&body_, &extras_);

    uint32_t ext_len = 0;
    char *ext_hdr = NULL;
    int ext_hdr_len = extras_.size() * 3;
    std::map<int8_t, Buffer>::iterator it;

    if (extras_.size() > 0) {
        ext_hdr = new char [ext_hdr_len];
        ExtHeader::Builder ext_builder(ext_hdr);

        for (it = extras_.begin(); it != extras_.end(); it++) {
            ext_len += it->second.len();
            ext_builder.AddExtItem(it->first, it->second.len());
        }
    }

    hdr.set_type(Header::kRequest);
    hdr.set_id(msg_->id());
    hdr.set_body_type(msg_->type());
    hdr.set_body_size(body_.len());
    hdr.set_ext_count(extras_.size());
    hdr.set_ext_len(ext_len);
    hdr.Build();

    //hdr
    buffers->push_back(boost::asio::buffer(header_, Header::kByteSize)); 

    //body
    buffers->push_back(boost::asio::buffer(body_.ptr(), body_.len()));

    // ext_hdr
    if (ext_hdr != NULL && ext_hdr_len > 0) {
        buffers->push_back(boost::asio::buffer(ext_hdr, ext_hdr_len));
    }

    //ext_body
    for (it = extras_.begin(); it != extras_.end(); it++) {
        buffers->push_back(boost::asio::buffer(it->second.ptr()
                    , it->second.len()));
    }
}

Response::Response(IncomingMsg *msg
        , const Buffer &buffer
        , const std::map<int8_t, Buffer> &extra)
    : msg_(msg)
      , buffer_(buffer)
      , last_(false)
      , extras_(extra)
      , type_(Packet::kIncoming)
{
}

Response::~Response()
{
    if (last_ && msg_ != NULL) {
        delete msg_;
    }
}

void Response::AppendTo(std::vector<boost::asio::const_buffer>* buffers)
{
    CHECK_NOTNULL(buffers);

    Header::Builder hdr(header_);

    uint32_t ext_len = 0;
    char *ext_hdr = NULL;
    int ext_hdr_len = extras_.size() * 3;
    std::map<int8_t, Buffer>::iterator it;

    if (extras_.size() > 0) {
        ext_hdr = new char [ext_hdr_len];
        ExtHeader::Builder ext_builder(ext_hdr);

        for (it = extras_.begin(); it != extras_.end(); it++) {
            ext_len += it->second.len();
            ext_builder.AddExtItem(it->first, it->second.len());
        }
    }

    hdr.set_type(last_ ? Header::kLast : Header::kResponse);
    hdr.set_id(msg_->id());
    hdr.set_body_type(msg_->type());
    hdr.set_body_size(buffer_.len());
    hdr.set_ext_count(extras_.size());
    hdr.set_ext_len(ext_len);
    hdr.Build();

    buffers->push_back(boost::asio::buffer(header_, Header::kByteSize)); 
    buffers->push_back(boost::asio::buffer(buffer_.ptr()
                , buffer_.len()));

    // ext_hdr
    if (ext_hdr != NULL && ext_hdr_len > 0) {
        buffers->push_back(boost::asio::buffer(ext_hdr, ext_hdr_len));
    }

    //ext_body
    for (it = extras_.begin(); it != extras_.end(); it++) {
        buffers->push_back(boost::asio::buffer(it->second.ptr()
                    , it->second.len()));
    }
}

Ctrl::Ctrl(MsgId msg_id, uint8_t ctrl_type) 
    : msg_id_(msg_id), ctrl_type_(ctrl_type), type_(Packet::kControl)
{
}

Ctrl::~Ctrl()
{
}

void Ctrl::AppendTo(std::vector<boost::asio::const_buffer>* buffers)
{
    CHECK_NOTNULL(buffers);

    Header::Builder hdr(header_);
    hdr.set_type(ctrl_type_);
    hdr.set_id(msg_id_);
    hdr.set_body_type(0);
    hdr.set_body_size(0);
    hdr.set_ext_count(0);
    hdr.set_ext_len(0);
    hdr.Build();

    buffers->push_back(boost::asio::buffer(header_, Header::kByteSize)); 
}

} /*net*/
} /*ldd*/


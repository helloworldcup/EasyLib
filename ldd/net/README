ldd::net 结构设计

IncomingMsg:
代表一个*接收*到的请求消息。
封装了接受请求后的处理逻辑。
负责此响应的投递。

OutgoingMsg:
代表一个*发送*出去的请求消息。
负责此请求的投递。
封装了响应消息的处理逻辑。

Service:
代表一个事件驱动的线程池。

UpStream:
代表一个本地TCP端口的监听服务，生成链接。
需要以一个Service对象为基础。
*不管理*UpStreamChannel。
所管理的所有UpStreamChannel由其Service驱动。
InStream会创建一个独立于Service的线程，处理Accept
注册和管理IncomingMsg Factory

DownStream:
代表一个可以主动向其他Server发起链接的对象。
负责DownStreamChannel的创建。
*不管理*DownStreamChannel。
所创建的所有DownStreamChannel由其Service驱动。
注册和管理IncomingMsg Factory

Channel:
代表一个TCP链接。

UpStreamChannel:
代表一个由UpStream Accept到的TCP链接。
管理所有IncomingMsg及投递给此Channel的OutgoingMsg的生存期。
连接错误/中断后，所有内部的IncomingMsg/OutgoingMsg的处理以失败结束。

DownStreamChannel:
代表一个由Downstream主动发起的TCP链接。
管理所有IncomingMsg及投递给此Channel的OutgoingMsg的生存期。
链接错误/中断后，进入重连逻辑。
所有内部的IncomingMsg/OutgoingMsg由超时进行控制。
主动调用DownStreamChannel的Close接口关闭链接后，所有内部的IncomingMsg/OutgoingMsg的处理以失败结束。


////////////////////////////////////////////
typedef function<void(shared_ptr<Channel>)> ChannelHandler;

::ldd::net::Service* service = new ldd::net::Service(8);
::ldd::net::UpStream* us = new ldd::net::UpStream(&service, 9999, channel_handler);

us->Register<IncomingGetMsg>();           // derived from IncomingMsg
us->Register<IncomingPutMsg>();           // derived from IncomingMsg

if (!service->Start()) {
    exit(-1);
}

if (!us->Open()) {  // create thread, listen, etc.
    exit(-1);
}

// wait signal.
// ...
us->Close(); // stop listening
service->Stop(); // stop channel event processing.


////////////////////////////////////////////
::ldd::net::Service* service = new ldd::net::Service(8);
::ldd::net::DownStream* ds = new ldd::net::DownStream(&service);
ds->Register<IncomingReportMsg>();        // derived from IncomingStream
service->Run();

ds->Register<IncomingReportMsg>();        // derived from IncomingMsg

if (!server->Start()) {
    exit(-1);
}

OutgoingGetMsg* msg = new OutgoingGetMsg(my_buffer, my_context, ...);

shared_ptr<Channel> channel = ds->Connect(host, port);
channel->Send(msg);

// wait until msg is responsed.
// ...

service->Stop(); // stop channel event processing.


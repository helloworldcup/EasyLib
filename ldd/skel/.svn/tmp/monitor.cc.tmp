// monitor.cc (2013-08-01)
// Li Xinjie (xjason.li@gmail.com)

#include <iostream>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <boost/foreach.hpp>
#include <glog/logging.h>
#include "monitor.h"
#include "option.h"
#include "config.h"
#include "sigpipe.h"
#include "master.h"
#include "proctitle.h"

namespace ldd {
namespace skel {

using namespace std;
using namespace boost;

Monitor::Monitor()
    : stop_flag_(false)
{
}


bool Monitor::Init(int argc, char** argv) {
    config_.reset(new Config);
    std::string what;
    if (!config_->Init(&what)) {
        cerr << what << endl;
        return false;
    }
    stringstream title;
    title << "lddskel(" << Option::instance().name() << "): monitor process";
    for (int i = 0; i < argc; ++i) {
        title << " " << argv[i];
    }
    if (!ProcTitle::Init(argc, argv)) {
        cerr << "can't init proc title" << endl;
        return false;
    }
    ProcTitle::Set(title.str());
    return true;
}

void Monitor::Run() {
    monitor_runner_.reset(net::EventRunner::NewInplaceEventRunner());
    accept_runner_.reset(net::EventRunner::NewInplaceEventRunner());
    BOOST_FOREACH(int port, config_->ports()) {
        EventRunnerGroup* runners = NULL;
        if (config_->worker() == kWorkerThread) {
            runners = 
                net::EventRunnerGroup::NewEventRunnerGroup(config_->workers());
        }
        net::DownStream::Options options;
        options.accept_runner = accept_runner_.get();
        options.io_runners = runners_;
        if (config_->worker() == kWorkerProcess) {
            options.max_children = config_->workers();
            if (config_->workers() > 1) {
                options.accept_mutex = true;
            }
        }
        net::DownStream* downstream = new net::DownStream(options);
        if (!downstream->Init(port)) {
            delete downstream;
            exit(1);
        }
        listeners_.insert(port, downstream);
        if (runners) {
            thread_runners_.insert(port, runners);
        }
    }
    WatchSignals();
    RunMasters();
    Loop();
    StopChildren();
}

void Monitor::HandleSignal(net::Event::Type t, const net::Event& event) {
    int sig = 0;
    if (read(event.fd(), &sig, sizeof(sig)) <= 0) {
        LOG(ERROR) << "read signal: " << strerror(errno);
        stop_flag_ = true;
        monitor_runner_->Stop();
        return;
    }
    switch (sig) {
    case SIGINT:
    case SIGTERM:
    case SIGQUIT:
        LOG(INFO) << "TERM signal received";
        stop_flag_ = true;
        monitor_runner_->Stop();
        break;
    case SIGCHLD:
        LOG(INFO) << "CHLD signal recevied";
        HandleChild();
        break;
    case SIGHUP:
        LOG(INFO) << "HUP signal recevied";
        HandleReload();
        break;
    }
}

void Monitor::HandleChild() {
    int status = 0;
    pid_t pid = ::wait(&status);
    std::map<pid_t, int>::iterator it = childs_.find(pid);
    CHECK(it != childs_.end());
    int port = it->second;
    LOG(WARNING) << "master[" << port << "] on " << pid
        << " stopped with " << status << ", try restart...";
    net::TimerId timer = monitor_runner_->RunAfter(1000,
            boost::bind(&Monitor::RunMaster, this, port));
    restart_timers_[port] = timer;
}

void Monitor::HandleReload() {
<<<<<<< .mine
    Config* config = new Config;
    std::string what;
    if (!config->Init(&what)) {
        LOG(ERROR) << what;
        return;
    }

    if (config->ports() != config_->ports()) {
    }

    if (config->master() != config_->master()) {
    }

    RunMasters();
=======
    std::auto_ptr<Config> cfg(new Config);
    std::string what;
    if (!cfg->Init(&what)) {
        LOG(ERROR) << "Reload failed: " << what;
        return;
    }
    if (cfg->type() != config_->type()) {
        LOG(ERROR) << "Can't reload: changing module type is not supported";
        return;
    }
    if (cfg->ports() != config_->ports()) {
        LOG(ERROR) << "Can't reload: changing port is not supported";
        return;
    }

    LOG(INFO) << "Reloading...";
    typedef std::map<int, net::TimerId>::value_type PortAndTimer;
    BOOST_FOREACH(PortAndTimer& x, restart_timers_) {
        LOG(INFO) << "cancel timer for port " << x.first;
        monitor_runner_->DeleteTimer(x.second);
    }
    restart_timers_.clear();
    reloading_ = true;
>>>>>>> .r70239
}

void Monitor::WatchSignals() {
    SigPipe& sigpipe = SigPipe::instance();
    sigpipe.Init();
    sigpipe.InstallAll(SIGINT, SIGTERM, SIGQUIT,
            SIGCHLD, SIGHUP, 0);
    signal_event_.reset(monitor_runner_->NewEvent(sigpipe.fd(), 
            boost::bind(&Monitor::HandleSignal, this, _1, _2)));
    signal_event_->Add(net::Event::kReadable);
}

void Monitor::RunMasters() {
    if (config_->type() == kModuleNormal) {
        BOOST_FOREACH(int port, config_->ports()) {
            RunMaster(port);
        }
    } else {
        RunMaster(0);
    }
}

void Monitor::RunMaster(int port) {
    restart_timers_.erase(port);
    google::FlushLogFiles(0);
    int fd[2];
    int resfd[2];
    pipe(resfd);
    pipe(fd);
    char buf = 1;
    pid_t pid = fork();
    if (pid < 0) {
        LOG(ERROR) << "fork master[" << port << "] failed: " << strerror(errno);
        return;
    } else if (pid > 0) {
        // in monitor
        childs_[pid] = port;
        close(fd[0]);
        write(fd[1], &buf, 1);
        close(fd[1]);
<<<<<<< .mine

        read(resfd[0], &buf, 1);
        if (buf == 1) {
            // kill old master;
        } else {
            // 
        }
=======
        LOG(INFO) << "forked master[" << port << "] on " << pid;
>>>>>>> .r70239
        return;
    }
    // in master
    close(fd[1]);
    read (fd[0], &buf, 1);
    close(fd[0]);
    monitor_runner_->AfterFork();
    accept_runner_->AfterFork();

    signal_event_.reset();
    monitor_runner_.reset();
    SigPipe::instance().Close();
    Option& option = Option::instance();
    google::ShutdownGoogleLogging();
    FLAGS_log_dir = option.log_dir() + "/" + option.name();
    if (port != 0) {
        FLAGS_log_dir += "-" + lexical_cast<string>(port);
    }
    mkdir(FLAGS_log_dir.c_str(), 0755);
    google::InitGoogleLogging(option.name().c_str());

<<<<<<< .mine
    Master master(port, config_.get(), &listeners_);
    if (!master.Init()) {
        buf = 0;
        write(resfd[1], &buf, 1);
        exit(1);
=======
    int retval = 0;
    Master* master = new Master(port, config_.get(), &listeners_,
            accept_runner_.get(), thread_runners_.get());
    if (!master->Prepare()) {
        retval = 1;
        goto finish;
>>>>>>> .r70239
    }
<<<<<<< .mine
    write(resfd[1], &buf, 1);
    master.Run();
    exit(0);
=======
    if (!master->Load()) {
        retval = 2;
        goto finish;
    }
    if (!master->Init()) {
        retval = 3;
        goto finish;
    }
    master->Run();
finish:
    delete master;
    exit(retval);
>>>>>>> .r70239
}

void Monitor::Loop() {
    while (!stop_flag_) {
        monitor_runner_->Start();
        LOG(INFO) << "monitor runner paused";
    }
}

void Monitor::StopChildren() {
}


} // namespace skel
} // namespace ldd
